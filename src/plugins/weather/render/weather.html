{% extends "plugin.html" %}

{% block content %}
<div id="units-container" data-units="{{ units }}"></div>


<div class="weather-dashboard">
  {% if plugin_settings.displayRefreshTime == "true" %}
  <div class="last-refresh">{{ last_refresh_time }}</div>
  {% endif %}
  <!-- Current Date -->
  <div class="header">
    <div class="title">{{ title }}</div>
    <div class="current-date">{{ current_date }}</div>
  </div>

  <div class="today-container">
    <!-- Current Weather Row -->
    <div class="current-temperature">
      <!-- Icon Column -->
      <div class="current-icon-column">
        <img class="current-icon" src="{{current_day_icon}}" alt="Current Weather Icon">
      </div>
      <!-- Outdoor Data Column -->
      <div class="current-weather outdoor">
        <div class="temp-label">Outdoor</div>
        <div class="current-temp">{{ current_temperature }}<span class="temperature-unit">{{temperature_unit}}</span></div>
        <div class="feels-like">Feels Like {{ feels_like }}{% if units != "standard" %}°{% endif %}</div>
        <div class="min-max">{{ forecast[0].low }}{% if units != "standard" %}°{% endif %} / {{ forecast[0].high }}{% if units != "standard" %}°{% endif %}</div>
      </div>
      <!-- Indoor Data Column -->
      {% if indoor_temperature is not none or indoor_humidity is not none %}
      <div class="current-weather indoor">
        <div class="temp-label">Indoor</div>
        {% if indoor_temperature is not none %}
        <div class="current-temp">{{ indoor_temperature }}<span class="temperature-unit">{{temperature_unit}}</span></div>
        {% endif %}
        {% if indoor_humidity is not none %}
        <div class="feels-like">Humidity</div>
        {% endif %}
        <div class="min-max">{{ indoor_humidity }}%</div>
      </div>
      {% endif %}
    </div>

    <!-- Data Points Grid (Sunset, Wind, UV, etc.) -->
    {% if plugin_settings.displayMetrics and  plugin_settings.displayMetrics == "true" %}
    <div class="data-points">
      {% for dp in data_points %}
        <div class="data-point column-container">
          <div class="data-point-img-container">
            <img class="data-point-icon" src="{{dp.icon}}" alt="{{ dp.label }}">
          </div>
          <div class="data-point-data">
            <div class="data-point-label">{{ dp.label }}</div>
            <div class="data-point-measurement">
			        {{ dp.measurement }}{% if dp.unit %}<span class="data-point-unit">{{ dp.unit }}</span>{% endif %}
              {% if dp.label == "Wind" %}
                <span class="wind-arrow-symbol" style="margin-left: -5px;">{{ dp.arrow }}</span>
              {% endif %}
		    	 </div>
          </div>
        </div>
      {% endfor %}
    </div>
    {% endif %}
  </div>

  <!-- Hourly Temperature Graph -->
  {% if plugin_settings.displayGraph and plugin_settings.displayGraph == "true" %}
  <div class="chart-container">
    <canvas id="hourlyTemperatureChart"></canvas>
  </div>
  {% endif %}

  <!-- Forecast Row -->
  {% if plugin_settings.displayForecast and plugin_settings.displayForecast == "true" %}
  <div class="forecast">
    {% for day in forecast[1:(plugin_settings.forecastDays | int) + 1] %}
      <div class="forecast-day">
        <div class="forecast-day-name">{{ day.day }}</div>
        <img class="forecast-icon" src="{{day.icon}}" alt="{{ day.day }} Weather Icon">
        <div class="forecast-temps">
          <span class="low">{{ day.low }}{% if units != "standard" %}°{% endif %}</span> /
          <span class="high">{{ day.high }}{% if units != "standard" %}°{% endif %}</span>
        </div>
        {% if plugin_settings.moonPhase and plugin_settings.moonPhase == "true" %}
        <div class="separator"></div>
        <div class="moon-phase-container">
        <img class="moon-phase-icon" src="{{day.moon_phase_icon}}" alt="Moon phase icon">
        <span style="flex: 1;">{{day.moon_phase_pct}} %</span>
        </div>
        {% endif %}
      </div>
    {% endfor %}
  </div>
  {% endif %}

  <!-- Quote of the Day -->
  {% if quote %}
  <div class="quote-container">
    <div class="quote-text">"{{ quote }}"<span class="quote-author"> — {{ quote_author }}</span></div>
    
  </div>
  {% endif %}
</div>

<script src="{{static_dir}}/scripts/chart.js" charset="UTF-8"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const canvas = document.getElementById('hourlyTemperatureChart');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();

    // Extract hourly temperature and labels from template variables
    const labels = [{% for hour in hourly_forecast %}"{{ hour.time }}"{% if not loop.last %}, {% endif %}{% endfor %}];
    const temperatures = [{% for hour in hourly_forecast %}{{ hour.temperature }}{% if not loop.last %}, {% endif %}{% endfor %}];
    const precipitation = [{% for hour in hourly_forecast %}{{ hour.precipitation * 100}}{% if not loop.last %}, {% endif %}{% endfor %}]; // Convert to percentage
    const rain = [{% for hour in hourly_forecast %}{{ hour.rain or 0 }}{% if not loop.last %}, {% endif %}{% endfor %}];
    const units = document.getElementById('units-container').dataset.units;
    const isImperial = units === "imperial";
    const unit = isImperial ? "in" : "mm";
    const threshold = isImperial ? 0.0035 : 0.09;

    // Sunrise/sunset times for indicators
    const sunriseTime = "{{ sunrise_time or '' }}";
    const sunsetTime = "{{ sunset_time or '' }}";

    // Find min and max temperatures with padding for better visualization
    const minTemp = Math.min(...temperatures);
    const maxTemp = Math.max(...temperatures);
    const tempRange = maxTemp - minTemp;
    const tempPadding = Math.max(tempRange * 0.15, 2); // At least 2 degrees padding
    const chartMinTemp = Math.floor(minTemp - tempPadding);
    const chartMaxTemp = Math.ceil(maxTemp + tempPadding);

    // Calculate middle temperature for labels
    const midTemp = Math.round((chartMinTemp + chartMaxTemp) / 2);

    // Plugin for temperature labels on key points
    Chart.register({
      id: 'tempLabelsPlugin',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx, scales } = chart;
        const xScale = scales.x;
        const yScale = scales.y;
        const temps = pluginOptions.temperatures || [];

        ctx.save();
        ctx.font = 'bold 16px Jost';
        ctx.fillStyle = "{{ plugin_settings.textColor }}";
        ctx.textAlign = 'center';

        // Show temperature labels every 6 hours
        temps.forEach((temp, i) => {
          if (i % 6 === 0) {
            const x = xScale.getPixelForValue(i);
            const y = yScale.getPixelForValue(temp);
            ctx.fillText(temp + '°', x, y - 30);
          }
        });

        ctx.restore();
      }
    });

    // Plugin for rain annotations with overlap prevention
    Chart.register({
      id: 'annotationRain',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx } = chart;
        const rainData = pluginOptions.precipitationData || [];
        const meta = chart.getDatasetMeta(1);

        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = 'bold 13px Jost';

        // Track last drawn label position to prevent overlaps
        let lastLabelX = -Infinity;
        const minLabelSpacing = 45; // Minimum pixels between labels

        // First pass: collect all rain points that need labels
        const rainPoints = [];
        meta.data.forEach((point, i) => {
          const rainAmount = rainData[i];
          if (rainAmount && rainAmount > threshold) {
            rainPoints.push({ point, rainAmount, index: i });
          }
        });

        // Second pass: draw labels with overlap prevention
        rainPoints.forEach(({ point, rainAmount }) => {
          const x = point.x;
          const y = point.y;
          const base = chart.scales.y1.bottom;
          const height = base - y;

          // Skip if too close to last label
          if (x - lastLabelX < minLabelSpacing) {
            return;
          }

          let textY;
          if (height < 30) {
            textY = y - 8;
          } else {
            textY = y + 14;
          }
          ctx.fillStyle = "{{ plugin_settings.textColor }}";
          ctx.fillText(rainAmount.toFixed(2) + unit, x, textY);
          lastLabelX = x;
        });

        ctx.restore();
      }
    });

    const chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            type: 'line',
            label: 'Hourly Temperature',
            data: temperatures,
            borderColor: 'rgba(241, 122, 36, 1)',
            borderWidth: 3,
            pointRadius: 0,
            fill: false,
            tension: 0.4,
            order: 1
          },
          {
            type: 'line',
            label: 'Precipitation Probability',
            data: precipitation,
            borderColor: 'rgba(26, 111, 176, 0.9)',
            borderWidth: 2.5,
            pointRadius: 0,
            yAxisID: 'y1',
            fill: false,
            tension: 0.4,
            order: 2
          }]
        },
        options: {
          animation: {
            duration: 0
          },
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              top: 35
            }
          },
          scales: {
            x: {
              ticks: {
                autoSkip: true,
                maxTicksLimit: 12,
                padding: 2,
                maxRotation: 0,
                minRotation: 0,
                color: "{{ plugin_settings.textColor }}",
                font: {
                  family: 'Jost',
                  size: 13,
                  weight: 'bold'
                }
              },
              grid: {
                display: false
              },
              offset: true
            },
            y: {
              position: 'left',
              ticks: {
                padding: 6,
                color: "{{ plugin_settings.textColor }}",
                font: {
                  family: 'Jost',
                  size: 16,
                  weight: 'bold'
                },
                stepSize: 2,
                callback: function(value) {
                  return value + '°';
                }
              },
              grid: {
                display: false
              },
              min: chartMinTemp,
              max: chartMaxTemp
            },
            y1: {
              position: 'right',
              grid: { display: false },
              ticks: {
                padding: 6,
                color: "{{ plugin_settings.textColor }}",
                font: {
                  family: 'Jost',
                  size: 12,
                  weight: 'bold'
                },
                stepSize: 50,
                callback: function(value) {
                  if (value === 0 || value === 50 || value === 100) {
                    return value + '%';
                  }
                  return '';
                }
              },
              min: 0,
              max: 100
            }
          },
          plugins: {
            legend: { display: false },
            tempLabelsPlugin: {
              temperatures: temperatures
            },
            {% if plugin_settings.displayRain == "true" %}
            annotationRain: { precipitationData: rain }
            {% endif %}
          },
          elements: {
            line: {
              borderJoinStyle: 'round'
            }
          }
        }
      });

      // Apply gradients after chart creation
      const gradientStart = chart.scales['y'].getPixelForValue(chartMaxTemp);
      const gradientEnd = chart.scales['y'].getPixelForValue(chartMinTemp);

      // Temperature gradient - more subtle and transparent
      const tempGradient = ctx.createLinearGradient(0, gradientStart, 0, gradientEnd);
      tempGradient.addColorStop(0, 'rgba(252, 180, 50, 0.5)');
      tempGradient.addColorStop(0.5, 'rgba(252, 200, 80, 0.25)');
      tempGradient.addColorStop(1, 'rgba(252, 220, 120, 0.02)');
      chart.data.datasets[0].backgroundColor = tempGradient;

      // Precipitation gradient - smoother and more transparent
      const precipGradientStart = chart.scales['y1'].getPixelForValue(100);
      const precipGradientEnd = chart.scales['y1'].getPixelForValue(0);
      const precipitationGradient = ctx.createLinearGradient(0, precipGradientStart, 0, precipGradientEnd);
      precipitationGradient.addColorStop(0, 'rgba(26, 111, 176, 0.5)');
      precipitationGradient.addColorStop(0.5, 'rgba(80, 150, 200, 0.2)');
      precipitationGradient.addColorStop(1, 'rgba(150, 200, 230, 0)');
      chart.data.datasets[1].backgroundColor = precipitationGradient;

    chart.update();
  });
</script>
{% endblock %}
